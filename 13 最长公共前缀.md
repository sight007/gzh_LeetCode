# **最长公共前缀**

**编写一个函数来查找字符数组中的最长公共前缀。如果不存在公共前缀，返回空字符串""。**



#### 方法一：水平扫描法

假设一组字符串的最长公共前缀为LCP(S1...Sn)，那么LCP(S1...Sn)=LCP(LCP(LCP(S1,S2),S3),...Sn)。

也就是说，找到两个字符串的最长公共子串prefix，然后prefix与后面的一个字符串求最长公共子串。后面的每个字符串都做这样的操作。

`int indexOf(String str)`：返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。

所以当等于0时，就表示出现了前缀公共子串。	  

```java
public static String longestCommonPrefix(String[] strs) {
	if(strs.length() == "") return "";

	String prefix = strs[0];
	 
	for(int i=1; i<strs.length; i++) {
		while(strs[i].indexOf(prefix) != 0) {
			prefix = prefix.substring(0, prefix.length()-1);
			if(prefix == "") return "";
		}
	}

	return prefix;
}
```

**复杂度分析**：时间复杂度为O(S),S表示字符串中字符数量的总和。最坏情况是，只有两个字符串，且只有第一个字符相同。



#### 方法二：水平扫描 

对于前面的方法，如果最后一个字符串非常短，比较次数依旧为S，效率不高。

如果把所有的字符串列成一列，每次只比较一个字符是否相等，这样可以避免方法一的情况。

```java
public static String longestCommonPrefix3(String[] strs) {
	
	if(strs == null || strs.length == 0) return "";
	
	for(int i=0; i<strs[0].length(); i++){
		char c = strs[0].charAt(i);
		for(int j=1; j<strs.length; j++) {
				
			//如果相同位置上的字符不相同，那就说明肯定不是公共子串
			//如果长度小于检查的子串，那就说明肯定不是公共子串    i==strs[j].length() strs[j]比
			if(strs[j].charAt(i) != c || i==strs[j].length()) {
				return strs[0].substring(0, i);
			}
		}
	}
	
	return strs[0];
}
```



#### 方法三：分治法

这种办法来自于方法一的LCP操作，即两两求最长公共前缀。因此，分治法把这个问题拆分成若干的相同结构的小结构，最小的结构就是一个单词。

分治法用递归实现，具体的实现步骤是一颗二叉树。

![](.\img\13.1.png)

```java
public class FenZhiLongestSubString {

	public static String longestCommonPrefix(String[] strs) {
		if (strs == null || strs.length == 0)
			return "";
		return longestCommonPrefix(strs, 0, strs.length - 1);
	}

	private static String longestCommonPrefix(String[] strs, int l, int r) {
		if (l == r) {
									//System.out.println("longestCommonPrefix: "+strs[l]);
			return strs[l];
		} else {
			int mid = (l + r) / 2;
											 		//System.out.println("\n开始左函数");
			String lcpLeft = longestCommonPrefix(strs, l, mid);
													//System.out.println("\n开始右函数");
			String lcpRight = longestCommonPrefix(strs, mid + 1, r);
			return commonPrefix(lcpLeft, lcpRight);
		}
	}

	static String commonPrefix(String left, String right) {
		int min = Math.min(left.length(), right.length());
		for (int i = 0; i < min; i++) { 
			if (left.charAt(i) != right.charAt(i)) {
							//System.out.println("\n开始调用commonPrefix: "+left.substring(0, i));
				return left.substring(0, i);
			}
		}
		return left.substring(0, min);
	}	
	
	public static void main(String[] args) {
		String[] arr = new String[] {"leets","leetcode","leet","leeds"};
		System.out.println(longestCommonPrefix(arr));
	}

}
```

结果：

```
开始左函数

开始左函数
longestCommonPrefix: leets

开始右函数
longestCommonPrefix: leetcode

开始调用commonPrefix: leet

开始右函数

开始左函数
longestCommonPrefix: leet

开始右函数
longestCommonPrefix: leeds

开始调用commonPrefix: lee
lee
```

只要明白这是树的中序遍历方式就知道递归是怎么回事。



