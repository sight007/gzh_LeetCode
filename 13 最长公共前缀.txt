/**
 * 编写一个函数来查找字符数组中的最长公共前缀。
 * 如果不存在公共前缀，返回空字符串""。
 *
 *
 */
 
/**
 * 方法一：水平扫描法
 * 
 * 假设一组字符串的最长公共前缀为LCP(S1...Sn)，那么LCP(S1...Sn​)=LCP(LCP(LCP(S1​,S2​),S3​),...Sn​)
 *
 * 也就是说，找到两个字符串的最长公共子串prefix，然后prefix与后面的一个字符串求最长公共子串。
 * 后面的每个字符串都做这样的操作。
 *
 * int indexOf(String str)：返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
 * 所以当等于0时，就表示出现了前缀公共子串
 *
 */
 
 public static String longestCommonPrefix(String[] strs) {
		  
	if(strs.length() == "") return "";
	
	String prefix = strs[0];
		 
	for(int i=1; i<strs.length; i++) {
		while(strs[i].indexOf(prefix) != 0) {
			prefix = prefix.substring(0, prefix.length()-1);
			if(prefix == "") return "";
		}
	}
	
	return prefix;
	
}

//时间复杂度为O(S),S表示字符串中字符数量的总和。最坏情况是，只有两个字符串，且只有第一个字符相同。



/**
 * 方法二：水平扫描
 * 
 *	对于前面的方法，如果最后一个字符串非常短，比较次数依旧为S，效率不高
 *  如果把所有的字符串列成一列，每次只比较一个字符是否相等，这样可以避免方法一的情况。
 *
 */

public static String longestCommonPrefix3(String[] strs) {
	
	if(strs == null || strs.length == 0) return "";
	
	for(int i=0; i<strs[0].length(); i++){
		char c = strs[0].charAt(i);
		for(int j=1; j<strs.length; j++) {
				
			//如果相同位置上的字符不相同，那就说明肯定不是公共子串
			//如果长度小于检查的子串，那就说明肯定不是公共子串    i==strs[j].length() strs[j]比
			if(strs[j].charAt(i) != c || i==strs[j].length()) {
				return strs[0].substring(0, i);
			}
		}
	}
	
	return strs[0];
}

/**
 *	分治法：
 *
 *
 */









