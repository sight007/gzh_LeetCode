## 25 K个一组翻转链表

**题目：**给你一个链表，每K个一组进行翻转，请你返回反转后的链表。K是一个整数，它的值小于或等于链表的长度。如果节点不是K的整数倍，那么请将最后剩余的节点保持原有的顺序。

```
示例 :

给定这个链表：1->2->3->4->5

当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5
```



#### 解法一（迭代）：

K个一组翻转链表，这K个为start节点到end节点，指向start的节点为pre，end的下一个节点为next。

只需要把这个K个节点反转好，把pre接到前面，把end接到后面。



思路很简单，但实现起来真的需要花费时间。

~~~java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        
        //K个一组翻转链表，这K个为start节点到end节点，指向start的节点为pre，end的下一个节点为next
        //只需要把这个K个节点反转好，把pre接到前面，把end接到后面
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        
        //指向start的节点
        ListNode pre = dummy;
        
        //end节点，只是初步赋值
        ListNode end = dummy;
        
        while(end.next != null){
            
            //找出end节点
            for(int i=0; i<k&&end!=null; i++) end=end.next;
            
            //如果还没到k个节点就end==null，那就执行停止吧，反正while后面有return
            if(end==null) break;
            
            //把end的下一个节点记录下来，免得覆盖
            ListNode next = end.next;
            
            ListNode start = pre.next;
            
            //截断end的后面，哈哈，幸亏把end.next记录下来了
            end.next = null;
            
            //翻转后把结果的结果连到pre后面
            pre.next = reverse(start);
            
            //为下一次迭代重新赋值，pre,start,end此时都在第K个节点
            start.next = next;
            pre = start;
            end = pre;
            
        }
        
        return dummy.next;
        
    }
    
    
    
    //原地反转链表，只需要迭代改变原有节点的next（head结束后变成尾节点）
    public ListNode reverse(ListNode head){
        
        //要翻转节点的next
        ListNode pre = null;
        
        //要翻转的当前节点
        ListNode curr = head;
        
        while(curr != null){
            
            //首先把原来顺序curr的下一个节点记录下来，免得被覆盖
            ListNode next = curr.next;
            
            //只需要改变的一条关系（最重要）
            curr.next = pre;
            
            //为下一次反转重新赋值
            //当前的节点变成下次的要指向的前一个结点
            pre = curr;
            //下一个节点变成要操作的节点
            curr = next;
        }
        
        //while结束后，curr为null，pre才是前一个节点
        return pre;
    }
    
}
~~~



#### 解法二（栈）：

栈先进后出，K个节点进去，出来自然实现翻转。

```java

```





#### 解法三（迭代）：

