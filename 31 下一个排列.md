## 31、下一个排列

实现获取下一个排列的函数，算法需要将给定的数字序列重新排列成自带你序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（既升序排列）。必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入输入位于左侧列，其相应输出位于右侧列。

```
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```



#### 解法：

所谓的字典序，就是指a>b>c>d>......>z等等的顺序，字符串比较用的就是字典序。

如1-9这9个数字，进行全排列。

- [1,2,3,4,5,6,7,8,9]是第一个序列
- [9,8,7,6,5,4,3,2,1]是最后一个序列
- 可以看出应该是由升序逐渐变化成降序的过程
- 如何求一个序列的下一个序列？
- 必然让前面不动，从后往前数，发现找到一个不是从小到大排列的数N。这说明这个排列时候还有下一个排列
- 再从N往后找，找到一个刚好小于N、在后面的数中最小的数（小数字典序靠前），交换
- 此时，后面的序列应该是除刚交换的那个数之外，其他都是降序的。将后面的数字重降序排列。



```java

```

