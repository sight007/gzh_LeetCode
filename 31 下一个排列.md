## 31、下一个排列

实现获取下一个排列的函数，算法需要将给定的数字序列重新排列成自带你序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（既升序排列）。必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入输入位于左侧列，其相应输出位于右侧列。

```
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```



#### 解法：

所谓的字典序，就是指a>b>c>d>......>z等等的顺序，字符串比较用的就是字典序。

如1-9这9个数字，进行全排列。

- [1,2,3,4,5,6,7,8,9]是第一个序列
- [9,8,7,6,5,4,3,2,1]是最后一个序列
- 可以看出应该是由升序逐渐变化成降序的过程
- 如何求一个序列的下一个序列？
- 必然让前面不动，从后往前数，发现找到一个不是从小到大排列的数N。这说明这个排列时候还有下一个排列
- 再从N往后找，找到一个刚好小于N、在后面的数中最小的数（小数字典序靠前），交换
- 此时，后面的序列都是降序的。将后面的数字重降序排列。



**如果有相等的数字出现，那么两个相等数字并列因该是上一个排列。所以，while要用大于等于，循环停止就不满足等于情况。**



```java
public void nextPermutation(int[] nums) {
        
        //i最大能取倒数第二个小下标
        int i = nums.length-2;
        
        //从后往前找，前面的数大就继续找，前面的数小就停止
        while(i>=0 && nums[i]>=nums[i+1]){
            i--;
        }
        
        
        //找到了从后往前的非升序的数
        int j =nums.length-1;
        if(i>=0){
            
            //找到nums[i]后面刚好大于它的值nums[j],
            while(j>=0 && nums[i]>=nums[j]){
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i+1);
    }
    
    
    public void reverse(int[] nums, int start){
        int end = nums.length-1;
        while(start<end){
            swap(nums, start, end);
            start++;
            end--;
        }
    }
    
    
    //交换两个数
    public void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```

